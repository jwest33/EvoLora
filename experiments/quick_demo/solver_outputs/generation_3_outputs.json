[
  "  # Round to 2 decimal places for currency\n\n# Example usage\n# calculate_final_price(100.0, 10.0, 8.5)  # Returns 97.65\n# calculate_final_price(50.0, 0.0, 0.0)   # Returns 50.0\n# calculate_final_price(100.0, 20.0, 15.0) # Returns 87.75\n\n# Test cases\n# calculate_final_price(100.0, 10.0, 8.5)  # 97.65\n# calculate_final_price(50.0, 0.0, 0.0)   # 50.0\n# calculate_final_price(100.0, 20.0, 15.0) # 87.75\n# calculate_final_price(0.0, 0.0, 0.0)    # 0.0\n\n# Edge cases\n# calculate_final_price(0.0, 0.0, 0.0)    # 0.",
  "\n\n\ndef find_last_occurrence(lst: List[Union[int, str]], target: Union[int, str]) -> Optional[int]:\n    \"\"\"\n    Find the index of the last occurrence of a target element in a list.\n\n    This function iterates through the list from the end to find the last index where\n    the target appears. If the target is not found, it returns None. The function\n    handles lists containing both integers and strings, and the target can be either\n    type.\n\n    Args:\n        lst: A list of integers and/or strings.\n        target: The element to search for in the list.\n\n    Returns:\n        The index of the last occurrence of the target in the list, or None if not found.\n\n    Raises:\n        TypeError: If the input list is not a list or if the target is not of an acceptable type.\n    \"\"\"\n    # Validate input types\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    if not isinstance(target, (int, str)):\n        raise TypeError(\"Target must be an integer or a string\")\n\n    # Iterate from the end to find the last occurrence\n    for index in range(len(lst) - 1, -1, -1):\n        if",
  "\n\n# Example usage:\n# calculate_discount(100.0, 10.0, 50.0)  # Returns 90.0\n# calculate_discount(40.0, 10.0, 50.0)  # Returns 40.0 (no discount due to insufficient minimum)\n\n# Note: The function assumes that discount is given as a percentage (e.g., 10 for 10%).\n# If the discount were to be interpreted as a flat amount, the function would behave differently.\n# This function is designed for percentage-based discounts.\n\n# The function is designed to be used in retail or e-commerce contexts where a minimum\n# purchase threshold is required to qualify for a discount.\n\n# The function does not apply any rounding, so results may have floating-point precision issues.\n# For financial applications, consider using rounding to two decimal places.\n\n# The function is stateless and pure \u2014 it does not modify any external state.\n# It only takes inputs and returns a value based on the rules defined.\n\n# Limitations:\n# - Does not validate if price is a valid monetary value (e.g., no cents over 99.99).\n# - Does not consider taxes",
  "\ndef generate_all_possible_combinations(n, k):\n    \"\"\"\n    Generate all possible combinations of k elements from a set of n elements.\n\n    This function generates all combinations of k elements chosen from a set of n\n    distinct elements, without repetition and without regard to order.\n\n    Parameters:\n    n (int): The total number of elements in the set.\n    k (int): The number of elements to choose for each combination.\n\n    Returns:\n    List[List[int]]: A list of all possible combinations, where each combination\n                     is represented as a list of integers.\n\n    Example:\n    generate_all_possible_combinations(4, 2) -> [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]\n\n    Notes:\n    - The function assumes that the elements are numbered from 0 to n-1.\n    - The input parameters must be non-negative integers with k <= n.\n    - If k is 0, the function returns an empty list.\n    - If k > n, the function raises a ValueError.\n    - The combinations are generated in lexicographic order.\n\n    Raises:\n    ValueError: If k > n or",
  "  # type: ignore\n\nWe are given a function that calculates the average of a list of integers.\nWe need to generate comprehensive documentation for this function.\n\nWe'll include:\n- A clear description of the function\n- Parameters with their types and descriptions\n- Return value description\n- Exception handling\n- Example usage (optional but recommended)\n- Notes on behavior and edge cases\n\nHere is the complete documentation:\n\n---\n\n```python\ndef calculate_average(numbers: list[int]) -> float:\n    \"\"\"\n    Calculate the average of a list of integers.\n\n    This function computes the arithmetic mean of a list of integers by summing all\n    the values and dividing by the count of numbers.\n\n    Args:\n        numbers: A list of integers. The list must not be empty.\n\n    Returns:\n        The average of the numbers as a floating-point number.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> calculate_average([1, 2, 3, 4, 5])\n        3.0\n\n        >>> calculate_average([10, 20])\n        15.0\n\n        >>> calculate_average([1])\n        1.0\n\n    Notes:\n        - The function handles both positive and negative integers",
  "\n\nWe are given a function that is supposed to be documented. We need to generate comprehensive documentation for the provided function.\n\nLet's break down the components of the function and create a well-structured, detailed documentation.\n\n---\n\n### Function: `complex_function`\n\n**Description:**\nThis function takes three integer inputs and computes the product of the sum of the first two inputs with the third. It includes validation to ensure that:\n- All inputs are non-negative.\n- The resulting value does not exceed 10^9.\n\n**Parameters:**\n- `a` (int): The first integer input.\n- `b` (int): The second integer input.\n- `c` (int): The third integer input.\n\n**Returns:**\n- int: The result of `(a + b) * c`, provided all constraints are satisfied.\n\n**Raises:**\n- `ValueError`: \n  - If any of the inputs `a`, `b`, or `c` is negative.\n  - If the computed result `(a + b) * c` exceeds `10**9`.\n\n**Examples:**\n```python\n>>> complex_function(2, 3, 4)\n20\n```\nExplanation: `(2 + 3) * 4 = ",
  "  # Explicitly cast to float, though it's already a float\n\ndef simple_function(a: int, b: int) -> int:\n    \"\"\"\n    A simple function that returns the sum of two integers.\n\n    Args:\n        a (int): First integer.\n        b (int): Second integer.\n\n    Returns:\n        int: The sum of a and b.\n\n    Raises:\n        TypeError: If a or b are not integers.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    return a + b\n\ndef main():\n    \"\"\"\n    Main function that demonstrates the usage of the complex and simple functions.\n    It includes error handling and provides examples of both normal and error cases.\n    \"\"\"\n    try:\n        # Test the complex function\n        result1 = complex_function(3, 4)\n        print(f\"complex_function(3, 4) = {result1}\")\n        \n        result2 = complex_function(5, 0)\n        print(f\"complex_function(5, 0) = {result2}\")\n        \n        result3 = complex_function(1, -1)\n        print(f\"complex_function(1, -1) = {result",
  "\n    pass\n\nWe are given a function definition with a typo in the docstring arguments.\nThe docstring lists an argument \"angle\" but the parameter list only has \"x\" and \"y\".\nWe need to correct the documentation and also provide a proper implementation.\n\nLet's fix the documentation and then implement the function.\n\nCorrected Documentation:\n\ndef my_function(x: float, y: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the lengths of two sides and the included angle.\n\n    Args:\n        x (float): Length of the first side of the triangle.\n        y (float): Length of the second side of the triangle.\n        angle (float): Included angle between sides x and y in degrees.\n\n    Returns:\n        float: The area of the triangle.\n\n    Raises:\n        ValueError: If either x or y is less than or equal to zero.\n        ValueError: If angle is not between 0 and 180 degrees (exclusive).\n\n    Note:\n        The angle must be in degrees. The formula used is:\n        area = 0.5 * x * y * sin(angle_in_radians)\n    \"\"\"\n    # Implementation here\n    pass\n\nHowever, note that the function signature does not include 'angle'",
  "  # Return in order: larger to smaller\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a prime number.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    \n    Args:\n        n: Integer to check for primality\n        \n    Returns:\n        True if n is a prime number, False otherwise\n        \n    Raises:\n        ValueError: If n is not a positive integer\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(n)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef find_primes_in_range(start: int, end: int) -> List[int]:\n    \"\"\"\n    Find all prime numbers in a given range [start, end).\n    \n    This function includes both endpoints if they are prime, but excludes the end point.\n    \n    Args:\n        start: Starting value of the range (inclusive)\n       ",
  "  # Example return\n\n# Example usage\nexample_function([1, 2, 3, 4, 5])  # Returns {'even': 2, 'odd': 3}\nexample_function([])  # Returns {'even': 0, 'odd': 0}\nexample_function([2, 4, 6])  # Returns {'even': 3, 'odd': 0}\nexample_function([1, 3, 5])  # Returns {'even': 0, 'odd': 3}\n\n# Error handling example\ntry:\n    example_function([1, 2, \"3\"])  # Raises TypeError\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n\n# Additional notes\n# The function is designed to be robust and handle edge cases.\n# It does not modify the input list.\n# The function assumes that all inputs are valid and will raise appropriate errors for invalid inputs.\n# This function can be used in data validation or preprocessing pipelines.\n# The output dictionary is always valid and contains only even and odd counts.\n# The function is thread-safe and can be used in concurrent environments.\n\n# Example of a more complex scenario\n# In a real-world application, this function might be part"
]